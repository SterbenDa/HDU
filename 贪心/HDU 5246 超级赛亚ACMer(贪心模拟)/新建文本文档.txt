超级赛亚ACMer
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 2245    Accepted Submission(s): 604


Problem Description
百小度是一个ACMer，也是一个超级赛亚人，每个ACMer都有一个战斗力，包括百小度。&#8232;所谓超级赛亚人的定义，是说如果在对抗中刚好接近极限状态，那就会激发斗志，实力提升.

具体来说，就是百小度现在要接受一些ACMer的挑战了，这些ACMer有n个人，第i个人的战斗力是a[i]。

&#8232;百小度接下来可以自主安排与这n个ACMer的PK顺序，他要想在PK赛中赢过另外一个ACMer，就必须使得自己的战斗力不小于对方（平局情况他会按照百小度字典上的规则把自己排在第一).

如果百小度的战斗力大于对方，那么百小度就会轻易获胜，得不到锻炼并且骄傲起来，他以后的战斗力将保持在这个值，再也不会发生改变。&#8232;如果百小度的战斗力等于对方，那么百小度在获胜的同时也会感到很吃力，但是这会激发百小度的斗志，使得他刻苦刷题，在下场PK赛之前，战斗力最多提升k点（即可以提升0~k点任意值）.

k是百小度的潜力提升上限，会被给定一个初始值，这个潜力提升上限k在后面的比赛中会下降.

每战胜一个ACMer，这个潜力上限k将减少1（因为超级赛亚人百小度也会感到累），但k最低只会减少到0，即不会出现战斗力下降的情况。也就是第一次比赛如果激发了百小度的斗志，他能把战斗力提升0~k的任一值，如果第二次比赛继续被激发斗志，他能在第一次提升后的基础上，把战斗力再提升0 ~ max(0,k?1),依次类推…

m是百小度的初始战斗力上限，也就是百小度第一次进行PK赛的时候，可以选择0~m的任意一个值作为他的战斗力.

现在希望你编写程序，判断一下百小度是否战胜所有的ACMer.
 

Input
输入包含多组数据（数据不超过500组)

第一行一个整数T，表示T组数据

对于每组数据，第一行包括三个整数n,m,k(1≤n≤104,1≤m,k≤108)

第二行包括n个正整数，表示彪形大汉的战斗力（战斗力为不超过1012的正整数）
 

Output
对于每组数据，先输出一行Case #i: (1≤i≤T)

如果百小度能打败所有的ACMer，再输出"why am I so diao?"

否则再输出"madan!"
 

Sample Input
2
5 11 3
15 13 10 9 8
5 11 3
8 9 10 13 16
 

Sample Output
Case #1:
why am I so diao?
Case #2:
madan!

Hint第一组样例解释
5个ACMer，初始战斗力选择范围是[0,11],接下来每场战斗力提升上限是3,2,1,0,0,...,0
百小度首先使得自己的初始战斗力为10，打败战斗力为10的第一个ACMer，
然后选择战斗力提升3，变成13，打败战斗力为13的第二个ACMer，
然后选择战斗力提升2，变成15，打败战斗力为15的第三个ACMer，
之后再以任意顺序打败剩下的ACMer 
 

Source
2015年百度之星程序设计大赛 - 初赛(1) 
