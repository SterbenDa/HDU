/*
题目大意：

输入一个整数,将这个数分解成不定个正数只和，要求这些数必须是2的k次方(k为大于等于0的正数).输出分的方法种数.(由于当输出整数过大时,种数很大只输出最后9位)

 

思路一：

 

设a[n]为和为 n 的种类数；
根据题目可知，加数为2的N次方，即 n 为奇数时等于它前一个数 n-1 的种类数 a[n-1] ，若 n 为偶数时分加数中有无 1 讨论，即关键是对 n 为偶数时进行讨论：
1.n为奇数，a[n]=a[n-1]
2.n为偶数：
（1）如果加数里含1，则一定至少有两个1，即对n-2的每一个加数式后面 +1+1，总类数为a[n-2]；
（2）如果加数里没有1，即对n/2的每一个加数式乘以2，总类数为a[n/2]；
所以总的种类数为：a[n]=a[n-2]+a[n/2];

画前8个可以很简单求出
  n为奇数
     a[n]=a[n-1]
  n为偶数 
   因为奇数是直接求前面那个，所以偶数时应该求的是n-2 加数是2的次方，
   偶数时  在n-2时每条式子+1+1 与dp[n-2]一样
           然后我的理解是 画所有式子找规律 发现剩下的没+1的式子为
		   n/2时的式子数   
    

*/
 

#include <stdio.h>
__int64 a[1000001];
int main()
{
    __int64 n;
 int i;
    a[1]=1;a[2]=2;
    for(i=3;i<1000001;i++)
    {
        if(i%2==0)
            a[i]=a[i-2]+a[i/2];
        else
            a[i]=a[i-1]; 
        a[i]%=1000000000;   //控制最多为9位.
    }
    while(scanf("%I64d",&n)!=EOF)
        printf("%I64d\n",a[n]);
    return 0;
}
